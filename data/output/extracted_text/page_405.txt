376
INPUT/OUTPUT 
CHAP. 5
If the disk driver accepts requests one at a time and carries them out in that
order, that is, FCFS (First-Come, First-Served), little can be done to optimize
seek time. However, another strategy is possible when the disk is heavily loaded. It
is likely that while the arm is seeking on behalf of one request, other disk requests
may be generated by other processes. Many disk drivers maintain a table, indexed
by cylinder number, with all the pending requests for each cylinder chained 
together in a linked list headed by the table entries.
Given this kind of data structure, we can improve upon the first-come, 
firstserved scheduling algorithm. To see how, consider an imaginary disk with 40 
cylinders. A request comes in to read a block on cylinder 11. While the seek to 
cylinder 11 is in progress, new requests come in for cylinders 1, 36, 16, 34, 9, and 12, in
that order. They are entered into the table of pending requests, with a separate 
linked list for each cylinder. The requests are shown in Fig. 5-22.
Initial!
position
Pending!
requests
Sequence of seeks
Cylinder
X
X
X X
X
X
X
0
5
10
15
20
25
30
35
Time
Figure 5-22. Shortest Seek First (SSF) disk scheduling algorithm.
When the current request (for cylinder 11) is finished, the disk driver has a
choice of which request to handle next. Using FCFS, it would go next to cylinder
1, then to 36, and so on. This algorithm would require arm motions of 10, 35, 20,
18, 25, and 3, respectively, for a total of 111 cylinders.
Alternatively, it could always handle the closest request next, to minimize seek
time. Given the requests of Fig. 5-22, the sequence is 12, 9, 16, 1, 34, and 36,
shown as the jagged line at the bottom of Fig. 5-22. With this sequence, the arm
motions are 1, 3, 7, 15, 33, and 2, for a total of 61 cylinders. This algorithm, called
SSF (Shortest Seek First), cuts the total arm motion almost in half versus FCFS.
Unfortunately, SSF has a problem. Suppose more requests keep coming in
while the requests of Fig. 5-22 are being processed. For example, if, after going to
cylinder 16, a new request for cylinder 8 is present, that request will have priority
over cylinder 1. If a request for cylinder 13 then comes in, the arm will next go to
13, instead of 1. With a heavily loaded disk, the arm will tend to stay in the middle
of the disk most of the time, so requests at either extreme will have to wait until a
statistical fluctuation in the load causes there to be no requests near the middle.
Requests far from the middle may get poor service. The goals of minimal response
time and fairness are in conflict here.
