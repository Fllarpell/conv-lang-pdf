952
CASE STUDY 2: WINDOWS 11
CHAP. 11
Figure 11-28. Native vs. WoW64 processes on an arm64 machine. Shaded areas
indicate emulated code.
handles NT system calls and wow64win.dll handles system calls that land in
win32k.sys. Exception dispatching is also conducted by this layer which translates
the 64-bit exception record generated by the kernel to 32-bit and dispatches to the
guest ntdll.dll. Finally, the WoW64 abstraction layer performs the namespace 
redirection necessary for 32-bit applications. For example, when a 32-bit 
application accesses c:\Windows\System32, it is redirected to c:\Windows\SysWoW64 or
c:\Windows\SysArm32 as appropriate. Similarly, some registry paths, for example
those under the SOFTWARE hive,
are redirected to a subkey called
WoW6432Node or WoWAA32Node, for x64 or arm64, respectively. That way, if the
32-bit and the 64-bit versions of the same component run, they do not overwrite
each other’s registry state.
The WoW64 CPU emulation layer is very much architecture dependent. Its job
is to execute the machine code for the guest architecture. In many cases, the host
CPU can actually execute guest instructions after going through a mode switch.
So, when running x86 code on x64 or arm32 code on arm64, the CPU emulation
layer only needs to switch the CPU mode and start running guest code. That’s what
wow64cpu.dll and wow armhw.dll do. However, that’s not possible when running
an x86 guest on arm64. In that case, the CPU emulation layer (xtajit.dll) needs to
perform binary translation to parse and emulate x86 instructions. While many
emulation strategies exist, xtajit.dll performs jitting, that is, just-in-time generation
of native code from guest instructions. In addition, xtajit.dll communicates with an
NT service called XtaCache to persist jitted code on disk such that it can prevent
re-jitting the same code when the guest binary runs again.
